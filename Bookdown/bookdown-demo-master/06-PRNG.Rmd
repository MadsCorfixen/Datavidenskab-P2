# Pseduo Random Number Generator

a method of generating a sequence of numbers that are not actually random, but share many properties with completely random numbers. These types of numbers are called pseudorandom numbers.

## Lineær Kongruens Generator

Lineær Kongruens Generator (LCG) er en af de mange PRNG generatorer. Denne algoritme er en af de ældste og nemmeste at implementere. LCG finder en sekvens af tal ved rekursion, og kræver kun få parametre. Helt specifikt er algoritmen den angivet ved

>```{definition}
> $X_(n+1) = (a \cdot X_n + c) \mod m$. Her er m modulus, a er en faktor, m er tilvæksten, og X_0 er 'seed'
>```

Helt præcist fungerer algoritmen på denne måde: 
Der startes med en værdi angivet med 'seed'. Denne værdi bliver så multipliceret med værdien a og der bliver lagt en tilvækst c til. Til sidst tages modulus, m, af værdien. Modulus er en operator der dividerer et tal med et andet tal og returnerer restværdien.

I figuren nedenfor kan ses tre eksempler på dette. De to første eksempler har samme parametre, men forskellige 'seeds'. 

```{r, out.width='75%', fig.align='center', fig.cap="Kilde: Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=38637545 ", echo = FALSE}
knitr::include_graphics('images/LCG_eksempel.PNG')
```

I teorien kan parameterne antage et uendeligt antal værdier, men i praksis er der nogle der bruges oftere end andre. FIXME Kilde på disse parametre

Nedenfor ses et eksempel på et stykke kode der vil danne en sekvens af LCG tal. Hvis man for eksempel kørte koden med parametrene: lcg(9, 2, 0, 3) vil man få en sekvens der uendeligt returnerer værdierne 3, 6, 3, 6, 3, 6...

```{python}
def lcg(modulus, a, c, seed):
    """Linear congruential generator."""
    while True:
        seed = (a * seed + c) % modulus
        print(seed)
```

## Box-Muller transformation


Nedenfor illustreres Box-Muller transformationen i R. Først simuleres to populationer, ```U1``` og ```U2```, hvor $\mathrm{U1 \sim unif(0,1)}$ og $\mathrm{U2 \sim unif(0,1)}$.

```{r}
U1 <- runif(100000, 0, 1)
U2 <- runif(100000, 0, 1)
```

Disse to populationer benyttes nu til at oprette de to påstået standard normalfordelte populationer, ```Z1``` og ```Z2```.

```{r}
Z1 <- sqrt(-2*log(U1))*cos(2*pi*U2)
Z2 <- sqrt(-2*log(U1))*sin(2*pi*U2)
```

Det kan nu tjekkes deskriptivt, hvilken fordeling ```Z1``` og ```Z2``` har. Først oprettes et boksplot.

```{r}
boxplot(Z1, Z2, main = "Boksplot af Z1 og Z2")

OutVals1 = boxplot(Z1, plot = FALSE)$out
outliers_Z1 <- length(which(Z1 %in% OutVals1))

OutVals2 = boxplot(Z2, plot = FALSE)$out
outliers_Z2 <- length(which(Z2 %in% OutVals2))

outliers_Z1/length(Z1)
outliers_Z2/length(Z2)
```

Det ses på boksplottet, at...

Hernest kan der kigges på histogrammerne af ```Z1``` og ```Z2```.

```{r}
par(mfrow = c(1,2))
hist(Z1, main = "Histogram for Z1", ylab = "Frekvens")
hist(Z2, main = "Histogram for Z2", ylab = "Frekvens")
```

Det ses på histogrammerne, at...

Desuden er det også en konsekvens af Box-Muller transformationerne, at ```Z1``` og ```Z2``` er uafhængige. Dette tjekkes ved hjælp af nedenstående graf.

```{r}
plot(Z2 ~ Z1, main = "Graf for uafhængighed mellem Z1 og Z2")

# independent_variables <- as.numeric(c(z1, z2))
# independence_test <- chisq.test(variables)
# independence_test
```

Det ses tydeligt, at der ikke er nogen relation mellem ```Z1``` og ```Z2```, hvilket giver en god indikation for, at de er uafhængige.



