# Pseduo Random Number Generator

En computer fungerer i hovedtræk ved at den modtager et input, som det bearbejdes af en algoritme, som derefter giver et output. Der findes ingen algoritmer, som er i stand til at generer FIXME(på engelsk kaldes det truly random numbers, dækker ægte? eller rigtig? eller bare tilfældig?)ægte tilfældige tal, fordi gives det samme input, til den samme algoritme, vil det resultatet være det samme output som tidligere. Årsagen til dette er, at computer fungerer på baggrund af matematik og er derfor deterministisk. Det er dog muligt ved hjælp af en beregningsmodel, at skabe en abstraktion af ægte tilfældighed. Denne model kaldes _Pseudo Random Number Generator_ (PRNG)
En PRNGs funktionalitet beskrives ved forskellige karakteristika. Et karateristika er input, dette input kaldes for et FIXME _seed/frø_. På baggrund af det FIXME _seed/frø_ der gives, beregner algoritmen i PRNG, et output, som er et pseudo tilfældigt tal. Dette pseudo tilfældige tal anvendes herefter som et nyt FIXME _seed/frø_ i PRNGen, derved kører den rekursivt og genererer den en sekvens af pseudo tilfældige tal. Et andet karakteristika er FIXME _period/periode_, som beskriver hvor mange repetitioner PRNGen kan kører før den begynder at gentage sig selv. Et tredje karakteristika er FIXME _distribution/fordeling_, som beskriver fordelingen af de talværdier der genereres. FIXME (indsæt billede). Som det ses på figuren kan fordeligen være jævn, hvilket betyder at der er en god fordeling af de generet pseudo tilfældige tal. Er der derimod en partiskhed, som enten kan være høje værdier, lave værdier eller hvis der forekommer andre former for mønstre, vil anvendeligheden af PRNG mindske eller være helt uanvendelig. Jo tidligere et mønster opstår, samt tydeligheden af det, vil betyde at det for udefrakommende er let gennemskueligt, og derfor vil der være risiko for at algoritmen brydes.
FIXME[https://www.youtube.com/watch?v=4sYawx70iP4, 0-4:05]

Der findes et utal af forskellige PRNG, men John von Neumann udviklede en af de tidligste til computer. Algoritmen, _middle square method_, er i dag aldeles kendt, men primært som et historisk symbol begyndelsen af moderne PRNG. Svaghederne ved metoden er, at dens _periode_ oftest er ret kort og ved nok gentagelser begynder den at gentage den samme sekvens eller ryge ind i et uendeligt loop. I takt med udviklingen af de teknologiske hjælpe midler kom der ligeledes flere og stærkere PRNG til. En af de mere kendte og hyppigt anvendte er _linear congruential generator_, som gennemgåes i det følgnede afsnit. FIXME[https://books.google.co.th/books?id=ibpfxsxuCUAC&pg=PA12&dq=middel+square+method&hl=da&sa=X&ved=0ahUKEwjZ9Mn3i4voAhX-zDgGHd9RBlcQ6AEINjAB#v=onepage&q&f=false, s. 12-13]  


## Lineær Kongruens Generator

Det følgende afsnit er primært baseret på kilden. [@LCGinfo]
Lineær Kongruens Generator, på engelsk Linear __FIXME staves det Congruens eller Congruence__ Congruens Generator eller LCG, er en af de mange PRNG generatorer. Denne algoritme er en af de ældste og nemmeste at implementere. LCG danner en sekvens af tal ved rekursion, og kræver kun få parametre. Helt specifikt er algoritmen angivet ved

>```{definition}
> __FIXME(skal parentesen være der om (n+1)? Det er den ikke længere nede)__ $X_{(n+1)} = (a \cdot X_n + c) \mod m$. Her er m modulus, a er en faktor, m er tilvæksten, og $X_0$ er 'seed
> $X_{n+1} = (a \cdot X_n + c) \mod m$. Hvor $X_n$ er en liste af tal fra $X_0$ til $X_n$, $m$ er modulus, $a$ er en faktor, $c$ er tilvæksten, og $X_0$ er startpunktet
>```

Algoritmen fungerer således:
Der startes ved en værdi der bliver multipliceret med $a$ og der bliver lagt en tilvækst $c$ til. Derefter tages modulus, $m$, af værdien. Modulus er en operator der dividerer et tal med et andet tal og returnerer restværdien.

I figuren nedenfor kan ses tre eksempler på LCG i aktion. De to første eksempler har samme parametre, men forskellige startpunkter.

```{r, out.width='75%', fig.align='center', fig.cap=" 3 eksempler på LCG. Kilde: By Cmglee - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=38637545 ", echo = FALSE}
 knitr::include_graphics("images/LCG_eksempel.PNG")
```

I teorien er parameterne arbitrære, men i praksis bruges nogle værdier oftere end andre. Begrundelsen for dette er, at der findes "dårlige" værdier for parameterne, der vil returnere en tilsyneladende ikke-tilfældig sekvens af værdier. Et eksempel på dette er ved parameterne: $m = 64, a = 33$ og $c = 12$. Efter et antal rekursioner vil der ses et mønster i værdierne, og det blotte øje vil altså kunne se at denne sekvens i virkeligheden ikke er helt tilfældig. Dette vil vises om lidt:

FIXME Kilde på disse parametre, tabel i wiki??, https://en.wikipedia.org/wiki/Linear_congruential_generator#cite_note-Steele20-3

De følgende simuleringer er baseret på kilden [@LCGsimu], som også går mere i dybden om hvordan, man kan undersøge om ens parametre, genererer tilsyneladende tilfældige værdier.

Her ses et eksempel på en LCG generator. Der angives værdier for parametrerne, og algoritmen gentages $n$ antal gange, i dette tilfælde 100 gange. Dette er også et eksempel på en LCG sekvens med en periode på 16. Perioden fortæller, hvor mange værdier generatoren returnerer inden den gentager sig selv.  

```{r}
modulus <- 64
a <- 33
c <- 12
seed <- 57
n <- 100
r <- numeric(n)
r[1] <- seed

for (i in 1: (n-1))
{
  r[i +1] <- (a * r[i] + c) %% modulus
}

r
```

Plottes denne sekvens i et 2d punktplot, vil man se at værdierne ikke er tilfældige. Selv hvis man ændrer antallet af gange LCG køres igennem, vil det tydelige mønster ikke ændre sig.

```{r}
plot(r, main = "Eksempel på en ikke tilfældig LCG sekvens", xlab = "Indeks", ylab = "Sekvens værdier" )
```

Nedenfor vises et eksempel på hvordan man kan bruge LCG algortimen til at lave en uniform fordeling i intervallet [0, 1].

```{r}
modulus <- 86436
a <- 1093
c <- 0
seed <- 12
n <- 1000
r1 <- numeric(n)
r1[1] <- seed

for (i in 1: (n-1))
{
  r1[i +1] <- (a * r1[i] + c) %% modulus
}

```

```{r}
hist((r1 + 0.05)/modulus, main = "LCG Uniformfordeling", xlab = "Sekvens værdier", ylab = "Frekvens")
```

Her kan det også nævnes, at hvis man plotter de værdier algoritmen returnerer i et 2d punktplot, vil man se en tydeligere "tilfældig" fordeling, dog vil der stadig kunne ses et mønster.

```{r}
plot(r1, main = "2d plot af LCG sekvens", xlab = "Indeks", ylab = "Sekvens værdier")
```


Afslutningsvist vil der vises et eksempel, hvor der returneres en sekvens, der plottet i et 2d punktplot, ser tilfældig ud.

```{r}
modulus <- 86436
a <- 1093
c <- 18257
seed <- 12
n <- 1000
r2 <- numeric(n)
r2[1] <- seed

for (i in 1: (n-1))
{
  r2[i +1] <- (a * r2[i] + c) %% modulus
}


```

```{r}
plot(r2, main = "'Tilfældig' LCG Sekvens", xlab = "Indeks", ylab = "Sekvens værdier")
```

## Box-Muller-transformation

I dette afsnit beskrives Box-Muller-transformation, hvilket er en metode til at generere standard normalfordelte tal ud fra uniformt fordelte tal. Dette gøres for at belyse, hvordan en computer kan generere tilsyneladende tilfældige tal, der er normalfordelt. Afsnittet er skrevet med inspiration fra [@Box-Muller]. Metoden beskrives konkret i nedenstående sætning.

>```{theorem}
> Box-Muller-transformation
>
> Antag, at $U_1$ og $U_2$ er uafhængige stokastiske variabler, der begge er uniformt fordelt på intervallet $[0, 1]$. Lad $$Z_1 = \sqrt{-2 \mathrm{ln} U_1} \mathrm{cos}(2\pi U_2)~ \wedge~ Z_2 = \sqrt{-2 \mathrm{ln} U_1} \mathrm{sin}(2\pi U_2)$$. Så er $Z_1$ og $Z_2$ uafhængige stokastiske variabler, der er standard normalfordelt.
>```

### Efterprøvning i R

I det følgende afsnit efterprøves Box-Muller-transformationen i R.

Først simuleres to populationer, ```U1``` og ```U2```, hvor $\mathrm{U1 \sim unif(0,1)}$ og $\mathrm{U2 \sim unif(0,1)}$, som er de to uniformt fordelte populationer, der genereres normalfordelinger ud fra.

```{r, echo = FALSE, message=FALSE}
set.seed(2000)
library(mosaic)
library(e1071)
```

```{r}
U1 <- runif(n = 100000, min = 0, max = 1)
U2 <- runif(n = 100000, min = 0, max = 1)
```

Disse to populationer benyttes nu til at oprette de to påstået standard normalfordelte populationer, ```Z1``` og ```Z2```.

```{r}
Z1 <- sqrt(-2*log(U1))*cos(2*pi*U2)
Z2 <- sqrt(-2*log(U1))*sin(2*pi*U2)
```

Det kan nu undersøges deskriptivt, hvilken fordeling ```Z1``` og ```Z2``` har.

Først oprettes et boksplot af de to populationer.

```{r}
boxplot(Z1, Z2, main = "Boksplot af Z1 og Z2")
```

Det ses på boksplottet, at der er en indikation på normalfordeling med henvisning til de fire krav et boksplot af en normalfordeling opfylder. De fire krav er:

1) Median og middelværdi er lig hinanden.

2) Øvre og nedre kvartil er lige langt fra midten.

3) Der er lige mange outliers over øvre kvartil som under nedre kvartil.

4) 0,7 % af observationerne ligger som outliers.

Punkterne 2 og 3 tjekkes ved at betragte boksplottet, hvor der ikke umiddelbart synes at være noget, der modbeviser en normalfordeling af ```Z1``` og ```Z2```.

For at tjekke punkt 1, beregnes median (```median```) og middelværdi (```mean```) i kodestykket nedenfor.

```{r}
mean_Z1 <- mean(Z1)
median_Z1 <- median(Z1)

mean_Z2 <- mean(Z2)
median_Z2 <- median(Z2)


```

Dette giver henholdsvis en middelværdi og median for ```Z1``` på $`r mean_Z1`$ og $`r median_Z1`$, samt for ```Z2```  på $`r mean_Z2`$ og $`r median_Z2`$. Disse resultater ligger meget tæt på hinanden, og den meget lave værdi stemmer overens med forventningen om, at ```Z1``` og ```Z2``` er standard normalfordelt.

For at tjekke punkt 4, beregnes andelen af outliers i hvert boksplot i kodestykket nedenfor.

```{r}
OutVals1 <- boxplot(Z1, plot = FALSE)$out
outliers_Z1 <- length(OutVals1)

OutVals2 <- boxplot(Z2, plot = FALSE)$out
outliers_Z2 <- length(OutVals2)

outliers_andel_Z1 <- outliers_Z1/length(Z1)
outliers_andel_Z2 <- outliers_Z2/length(Z2)
```

Dette giver en andel af outliers i ```Z1``` på ```r outliers_andel_Z1``` og i ```Z2``` på ```r outliers_andel_Z2```. Dette svarer til cirka $0,7~ \%$ outliers i både ```Z1``` og ```Z2```, hvilket stemmer overens med punkt 4.

Der er altså ikke noget evidens imod, at ```Z1``` og ```Z2``` skulle være normalfordelt. Tværtimod underbygger beregningen af deres middelværdi, at de er _standard_ normalfordelte.

Hernest kigges der på histogrammerne for ```Z1``` og ```Z2```.

```{r}
par(mfrow = c(1,2))
hist(Z1, main = "Histogram for Z1", ylab = "Frekvens")
hist(Z2, main = "Histogram for Z2", ylab = "Frekvens")
```

Det ses tydeligt på histogrammerne, at de tilnærmelsesvist er normalfordelte, samt at de har en middelværdi på $\approx 0$ og en standardafvigelse på $\approx 1$, og derved er  ```Z1``` og ```Z2``` standard normalfordelte.

Desuden er det også en konsekvens af Box-Muller-transformationerne, at ```Z1``` og ```Z2``` er uafhængige. Dette undersøges ved hjælp af nedenstående graf.

```{r}
plot(Z2 ~ Z1, main = "Graf for uafhængighed mellem Z1 og Z2", col = rgb(red = 0, green = 0, blue = 0, alpha = 0.25), pch = 1, cex = 0.5)

```

Det ses tydeligt, at der ikke er nogen relation mellem ```Z1``` og ```Z2```, hvilket giver en god indikation for, at de er uafhængige.
