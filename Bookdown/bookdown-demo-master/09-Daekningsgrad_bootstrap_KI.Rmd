# Udregning af dækningsgrad

```{r echo = FALSE, include = FALSE}
library(boot)
```

I dette afsnit vil der undersøges om metoderne for at udregne konfidensintervallerne er præcise. Dette gøres ved at udregne dækningsgraden af konfidensintervallerne som de forskellige metoder har produceret. Processen er den samme som i afsnit \@ref(t-test2). 

Som det første oprettes en funktion, der udregner middelværdien for stikprøven, og tager en stikprøve og et indeks som _input_.

```{r}
meanFunc <- function(sample_pop, i){
  mean(sample_pop[i])
}
sand_middel <- 0 #Sand middelværdi
```

Det næste der udregnes er et konfidensinterval. Konfidensintervallet beregnes ved hjælp af funktionen ```boot.ci```, der kommer fra pakken ```boot```. Der bliver først lavet 100 konfidensintervaller på baggrund af normalfordelte stikprøver. Så undersøges der om middelværdien af populationen er i konfidensintervallet. Hvis det er tilfældet, vil _outputtet_ være ```TRUE```, hvis ikke vil det være ```FALSE```. Herefter indsættes disse _output_ i en matrix. Til sidst beregnes dækningsgraden som andelen af de intervaller, der indeholder den sande middelværdi. Denne proces udføres for de tre konfidensintervalmetoder, percentil, T og basic.

Her udføres processen for dækningsgraden på percentilmetoden.
```{r}
matriks_p <- matrix(ncol = 25, nrow = 100)
vector_p <- c()
for(n in seq(4, 100, 4)){
  res <- replicate(100,{
    stik <- rnorm(n)
    boot_stik <- boot(stik, statistic = meanFunc, 100)
    interval_perc <- suppressWarnings(boot.ci(boot_stik,
                                      type = c("perc"))$percent[4:5])
    tf <- interval_perc[1]<=sand_middel &
      interval_perc[2]>=sand_middel
  })
  matriks_p[,n/4] <- res
  vector_p <- append(vector_p, mean(matriks_p[,n/4]))
}
```

Her udføres processen for dækningsgraden på basic-metoden.
```{r}
matriks_b <- matrix(ncol = 25, nrow = 100)
vector_b <- c()
for(n in seq(4, 100, 4)){
  res <- replicate(100,{
    stik <- rnorm(n)
    boot_stik <- boot(stik, statistic = meanFunc, 100)
    interval_basic <- suppressWarnings(boot.ci(boot_stik,
                                       type = c("basic"))$basic[4:5])
    tf <- interval_basic[1]<=sand_middel &
      interval_basic[2]>=sand_middel
  })
  matriks_b[,n/4] <- res
  vector_b <- append(vector_b, mean(matriks_b[,n/4]))
}
```

Her udføres processen for dækningsgraden på T-metoden.
```{r}
bootstrap_t <- function(n, alpha){
  stik <- rnorm(n)
  middel_stik <- mean(stik)
  se_stik <- sd(stik)
  boot_stik <- replicate(100, {
    sample(stik, n, replace = TRUE)
  })
  t_stjerne <- c()
  for(i in 1:nrow(boot_stik)){
    t_stjerne <- append(t_stjerne, 
                        (mean(boot_stik[,i])-middel_stik)/
                          (sd(boot_stik[,i])))
  }
  
  KI <- c(middel_stik - (quantile(t_stjerne,
                                  probs = 1-alpha/2) * se_stik),
          middel_stik - (quantile(t_stjerne,
                                  probs = alpha/2) * se_stik))
  
  return(KI)
}

matriks_n <- matrix(ncol = 25, nrow = 100)
vector_n <- c()
for(n in seq(4, 100, 4)){
  res <- replicate(100,{
    interval_t <- unname(bootstrap_t(n, 0.05))
    tf <- interval_t[1]<=sand_middel & interval_t[2]>=sand_middel
  })
  matriks_n[,n/4] <- res
  vector_n <- append(vector_n, mean(matriks_n[,n/4]))
}
```

Til sidst illustreres dækningsgraden for de tre metoder i diagrammet på figur \@ref{fig:figur_deakning}. 

```{r, figur_deakning, echo=FALSE, fig.cap="Illustration af udviklingen af dækningsgraden når stikprøvestørrelsen bliver større"}
x <- seq(4, 100, 4)
plot(x, vector_p, type="l", col="red", ylab = "Dækningsgrad",
     xlab = "Stikprøvestørrelse", ylim = c(0.75, 1))
lines(x, vector_b, type="l", col="blue")
lines(x, vector_n, type="l", col="green")
abline(h=0.95, lty=5, col="black")
legend(83, 0.835, legend=c("Percentil", "Basic", "t"),
       col=c("red", "blue", "green"), lty=c(1,1,1), cex=0.8)
```

Her ses at




























