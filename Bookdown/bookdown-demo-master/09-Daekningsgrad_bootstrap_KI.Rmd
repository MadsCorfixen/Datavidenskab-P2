# Udregning af dækningsgrad
I dette afsnit vil der undersøges om metoderne for at udregne konfidensintervallerne er effektive. Dette gøres ved at udregne dækningsgraden af middelværdien for populationen og undersøge om middelværdien er i de konfidensintervaller, som de forskellige metoder har produceret.

```{r}
library(boot)
```

Som det første udregnes middelværdien for population. For at udregningen af middelværdien for populationen gerne skal kunne kaldes senere, laves der en function. Funktionen tager en stikprøve og et index som input.
```{r}
meanFunc <- function(sample_pop, i){
  mean(sample_pop[i])
}
sand_middel <- 0
```

Det næste der udføres er et konfidensinterval. Konfidensintervallet beregnes ved hjælp af r's indbyggede funktion "boot.ci". Der bliver lavet 100 konfidensintervaller på baggrund af en normalfordelt stikprøve. Så undersøges der om middelværdien af stikprøven er i intervallet, hvis den er vil outputtet være TRUE, hvis ikke vil det være FALSE. Herefter sættes disse outputs ind i en matrix. Til sidst beregnes dækningsgraden af de intervaller som indeholder den beregnede middelværdi. Denne proces udføres for de tre konfidensintervalmetoder, percentil, normal og basic.

Her udføres processen for for dækningsgraden på percentilmetoden.
```{r}
matriks_p <- matrix(ncol = 25, nrow = 100)
vector_p <- c()
for(n in seq(4, 100, 4)){
  res <- replicate(100,{
    stik <- rnorm(n)
    boot_stik <- boot(stik, statistic = meanFunc, 100)
    interval_perc <- suppressWarnings(boot.ci(boot_stik,
                                      type = c("perc"))$percent[4:5])
    tf <- interval_perc[1]<=sand_middel &
      interval_perc[2]>=sand_middel
  })
  matriks_p[,n/4] <- res
  vector_p <- append(vector_p, mean(matriks_p[,n/4]))
}
```

Her udføres processen for for dækningsgraden på basicmetoden.
```{r}
matriks_b <- matrix(ncol = 25, nrow = 100)
vector_b <- c()
for(n in seq(4, 100, 4)){
  res <- replicate(100,{
    stik <- rnorm(n)
    boot_stik <- boot(stik, statistic = meanFunc, 100)
    interval_basic <- suppressWarnings(boot.ci(boot_stik,
                                       type = c("basic"))$basic[4:5])
    tf <- interval_basic[1]<=sand_middel &
      interval_basic[2]>=sand_middel
  })
  matriks_b[,n/4] <- res
  vector_b <- append(vector_b, mean(matriks_b[,n/4]))
}
```

???
```{r}
bootstrap_t <- function(n, alpha){
  stik <- rnorm(n)
  middel_stik <- mean(stik)
  se_stik <- sd(stik)
  boot_stik <- replicate(100, {
    sample(stik, n, replace = TRUE)
  })
  t_stjerne <- c()
  for(i in 1:nrow(boot_stik)){
    t_stjerne <- append(t_stjerne, 
                        (mean(boot_stik[,i])-middel_stik)/
                          (sd(boot_stik[,i])))
  }
  
  KI <- c(middel_stik - (quantile(t_stjerne,
                                  probs = 1-alpha/2) * se_stik),
          middel_stik - (quantile(t_stjerne,
                                  probs = alpha/2) * se_stik))
  
  return(KI)
}

matriks_n <- matrix(ncol = 25, nrow = 100)
vector_n <- c()
for(n in seq(4, 100, 4)){
  res <- replicate(100,{
    interval_t <- unname(bootstrap_t(n, 0.05))
    tf <- interval_t[1]<=sand_middel & interval_t[2]>=sand_middel
  })
  matriks_n[,n/4] <- res
  vector_n <- append(vector_n, mean(matriks_n[,n/4]))
}
```

Til sidst illustreres dækningsgraden for de tre metoder i diagrammet på figur \ref{fig:figur_deakning}. Her ses at...(percentil-metoden performer bedre?), da den rammer dækningsgraden på $95\%$ først ved en stikprøvestørrelse på omkring $15$.
```{r, figur_deakning, echo=FALSE, fig.cap="Illustration af udviklingen af dækningsgraden når stikprøvestørrelsen bliver større"}
x <- seq(4, 100, 4)
plot(x, vector_p, type="l", col="red", ylab = "Dækningsgrad",
     xlab = "Stikprøvestørrelse", ylim = c(0.75, 1))
lines(x, vector_b, type="l", col="blue")
lines(x, vector_n, type="l", col="green")
abline(h=0.95, lty=5, col="black")
legend(83, 0.835, legend=c("Percentil", "Basic", "t"),
       col=c("red", "blue", "green"), lty=c(1,1,1), cex=0.8)
```






























